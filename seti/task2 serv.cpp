#include <iostream>
#include <winsock2.h> // подключение заголовочного файла сокетов
#include <windows.h>
#include <string>
#pragma comment (lib, "Ws2_32.lib")// подключение библиотеки сокетов
using namespace std;
#define SRV_PORT 1234 // порт сервера
#define BUF_SIZE 64
const string QUEST = "Who are you?\n";
int main() {
char buff[1024];
if (WSAStartup(0x0202, (WSADATA*)&buff[0])) {//в if-е мы говорим что будем использовать библиотеку версии 2
// а WSADATA содержит указатель на ту структуру данных с которой мы будем работать через наши сокеты
// в нашем слуаче это наша структура
cout << "Error WSAStartup \n" << WSAGetLastError(); // если не удалось установить версию библиотеки то идем сюда // Ошибка!
return -1;
}
SOCKET s, s_new; // переменные сокетов
int from_len;
char buf[BUF_SIZE] = { 0 };
sockaddr_in sin, from_sin; // структуры сокетов
s = socket(AF_INET, SOCK_STREAM, 0);// здесь создаем сокет и указываем что он принадлежит к семейству интернет протоколов
// версии 4 IPv4 (127.0.0.1)( то есть теперь мы можем использовать этот сокет только с такими адресами )
sin.sin_family = AF_INET;// заполняем структуру сокета (чтобы мы могли передавать ее и связываться через нее с другими сокетами, например, с сокетом сервера) определяет формат адреса тк протокол IPv4
sin.sin_addr.s_addr = 0;// адрес клиента
sin.sin_port = htons(SRV_PORT);//адрес порта htons - приводит обычный беззначный тип short в сетевой порядок байтов ( нужно чтобы
// сокеты смогли работать на своих уровнях)
bind(s, (sockaddr*)&sin, sizeof(sin));// (socket, указатель на структуру типа, длина структуры)
string msg, msg1;
listen(s, 3);// максимально допустимый размер очереди сообщений
while (1) {
from_len = sizeof(from_sin);// берем размер стркутуры сокета для запросов клиента
s_new = accept(s, (sockaddr*)&from_sin, &from_len);//Первый аргумент функции - сокет-дескриптор для принятия связей от клиентов. Второй аргумент - указатель на адрес клиента (структура sockaddr ) для соответствующего домена. Третий аргумент - указатель на целое число - длину структуры адреса.
//автоматически создает новый сокет, выполняет связывание и возвращает его дескриптор, а в структуру sockaddr заносит сведения о подключившемся клиенте (ip-адрес и порт)
cout << "new connected client! " << endl;
msg = QUEST;
while (1) {
send(s_new, (char*)&msg[0], msg.size(), 0);//отправка данных на сервер аргуметы такие же как recv, только если 4-ый равен 0, то запись в сокет происходит в порядке поступления
//Функция send возвращает управление сразу же после ее выполнения независимо от того, получила ли принимающая сторона наши данные или нет.

from_len = recv(s_new, (char*)buf, BUF_SIZE, 0); // Первый аргумент - сокет-дескриптор, из которого читаются данные. Второй и третий аргументы - соответственно, адрес и длина буфера для записи читаемых данных. Четвертый параметр - это комбинация битовых флагов, управляющих режимами чтения. Если 4-ый агумент равен нулю, то считанные данные удаляются из сокета.
//Функция же recv возвращает управление только после того, как получит хотя бы один байт.
buf[from_len] = 0;
msg1 = (string)buf;
cout << msg1 << endl;;
if (msg1 == "Bye")
break;
getline(cin, msg);
}
cout << "client is lost";
closesocket(s_new);// закрываем связь с сокетом
}
return 0;
}